$$$ LESSON STARTED ON SEPTEMBER 10, 2025.

* make it a habit of creating a scope function when writing code
* create the code the longest way and then update it to its shortest simplest form
* python will get what is inside the most inner parenthesis going to the most outer
*    # if n % 2 == 0:
     #     return True
     return True if n % 2 == 0 else False - shorter code than the one above it
* if the code is expected to return True, eliminate extra code and write it as it is like:
     return n % 2 == 0 - shortest code than the one above it
* match statement is like if else
    - the underscore in match statement is called "catch all"
* break in loop function will terminate the execution of the loop
* continue in loop function will still continue once the condition is relevant
* return will stop the loop function if the loop function is inside the defined function just to get the final value that the defined function is expected to get
* the underscore _ is the pythons placeholder instead of i. eg. for _ in range(): print(_)
* the conventional entry point when starting a python program is to create a main function
def main():
    ***** some codes here *****

if __name__ == "__main__":
    main()
    $$$ this can only be defined once. no multiple main functions.

* FOR LOOP - will loop depending on the given condition
* WHILE LOOP - will continue looping while the condition is true
* len - length in python will determine the length of an object or number of an item.
* to access the items on the list use indexing v[0]

* there are two ways of creating a dict.
    ex: using {}
            occupants = {"name_1": "doks", "name_2": "seph", "name_3": "poy"}
    ex: using the dict() function
            occupants.dict(name_1: "doks", name_2: "seph", name_3: "poy")
* to access the items on the dictionary use the key name v[keyname]
* write dictionary in a database format vertical instead of one-liner
* I can create a folder and then touch file inside that folder by ~$ mkdir sample_folder. ~$ touch sample_folder/sample_file.txt
* using relative import by adding __init__.py in each folder
* iterable - meaning is that an object that can be looped over
* CSV - comma, separated values
* single line multiple variable assignment: a,b,c = 1,2,3. print(a) = 1, print(b) = 2, print(c) = 3.

 * aside from list and dictionary, tuples, strings, sets, ranges, generators, file object (file IO), view object from dictionary (dict.keys(), dict.values(), dict.items() are iterables that can be used for for loop
* sorted() is a built-in function that returns a new sorted list from the elements of any iterable, leaving the original iterable unchanged.
* if the quotes will be used twice in one line, use single quote in one of the quote partner.eg. f"this is a sample f-string: {'name'}"
* instead of defining a function for simple usage, create an anonymous function 'lambda function' instead. check usage of lambda
* accessing the values from a dictionary: https://www.w3schools.com/python/python_dictionaries_access.asp

https://www.google.com/search?q=what+is+**+in+python&oq=what+is+**+in+python&gs_lcrp=EgZjaHJvbWUyDwgAEEUYORiRAhiABBiKBTIHCAEQABiABDIICAIQABgWGB4yCAgDEAAYFhgeMggIBBAAGBYYHjIICAUQABgWGB4yCAgGEAAYFhgeMggIBxAAGBYYHjIICAgQABgWGB4yCAgJEAAYFhge0gEINjk1MWowajeoAgCwAgA&sourceid=chrome&ie=UTF-8#vhid=GYmZuQIwb3XsdM&vssid=_o0fbaLCPJ5vm2roPg-zSmQc_45

    In Python, the double asterisk ** has two primary uses: Exponentiation Operator.
It serves as the exponentiation operator, calculating the power of a number. The number on the left of ** is the base, and the number on the right is the exponent.

    result = 2 ** 3  # This calculates 2 raised to the power of 3, which is 8
    print(result)

    Handling Keyword Arguments in Function Definitions and Calls (`: kwargs`):**
When used in a function definition as **kwargs (or any other name prefixed with **), it allows the function to accept an arbitrary number of keyword arguments. These arguments are collected into a dictionary within the function, where the keys are the argument names and the values are the argument values.

    def greet_person(**details):
        print(f"Hello, {details['name']}!")
        if 'age' in details:
            print(f"You are {details['age']} years old.")

    greet_person(name="Alice", age=30, city="New York")

    It can also be used to unpack a dictionary into keyword arguments when calling a function:

        def display_info(name, age):
        print(f"Name: {name}, Age: {age}")

    person_data = {'name': 'Bob', 'age': 25}
    display_info(**person_data)

LAMBDA FUNCTION

In Python, lambda is a keyword used to create small, anonymous functions. These are also known as lambda functions or lambda expressions. Unlike regular functions defined with the def keyword, lambda functions do not require a name and are typically used for single, simple operations where a full function definition would be unnecessarily verbose.
Here's what lambda does:
Creates an Anonymous Function: It allows you to define a function without explicitly giving it a name. This is useful when you need a function for a short period or as an argument to another function.
Single Expression: Lambda functions are restricted to a single expression. This expression is automatically evaluated and returned as the result of the function. There is no return statement needed.
Syntax: The basic syntax is lambda arguments : expression.
lambda: The keyword indicating the creation of a lambda function.
arguments: Zero or more arguments that the function takes, separated by commas.
expression: The single expression that the function evaluates and returns.
Example:

# A lambda function to double a number
doubler = lambda x: x * 2
print(doubler(5)) # Output: 10

# Using lambda with higher-order functions like map()
numbers = [1, 2, 3, 4]
squared_numbers = list(map(lambda x: x**2, numbers))
print(squared_numbers) # Output: [1, 4, 9, 16]

Key Uses:
Higher-order functions: Often used with functions like map(), filter(), sorted(), and reduce() that take other functions as arguments.
Simple callbacks: When a simple, one-line function is needed as a callback.
Short-lived functions: For operations that are only needed in a specific context and don't warrant a named function definition.

* """
NOTE:
   #  when using special character to match for the regex use \ to tell the program that the next the escape is the literal character that you wanted to match the expression.
   #     - e.g. \.edu$ will be interpreted as the program should check for .edu match
   #     - e.g. \$, \%, \@ etc... this will be match for: $, %, @ etc...

   # to split email from the email name and domain

username, domain = email.split("@")
print(f"username: {username}\ndomain: {domain}")

if username and domain.endswith(".edu"):
    print("the email is valid")
else:
    print("invalid email")


# other way of validating the email address
if username and "." in domain:
    print("the email is valid")
else:
    print("invalid email")
"""

